--- a/openbsd-compat/port-pase.c	1969-12-31 18:00:00.000000000 -0600
+++ b/openbsd-compat/port-pase.c	2016-02-08 19:54:38.054329701 -0600
@@ -0,0 +1,985 @@
+/*
+ *
+ * Copyright (c) 2016 IBM Corporation.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifdef __PASE__
+#define PORT_PASE_C
+
+#include "includes.h"
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <iconv.h>
+// #include <malloc.h>
+// #include <fcntl.h>
+#include <pwd.h>
+
+#include "xmalloc.h"
+#include "buffer.h"
+#include "key.h"
+#include "hostfile.h"
+#include "auth.h"
+#include "ssh.h"
+#include "log.h"
+#include "misc.h"
+#include "servconf.h"
+
+#include <as400_types.h>
+#include <as400_protos.h>
+
+/* Macros for handling 16-byte alignment of MI pointers */
+#define QUADWORD_ALIGNED_VAR_DECLARE(type, name) \
+type* name; \
+char name##_buf[sizeof(type) + 15]
+
+#define QUADWORD_ALIGNED_VAR_INIT(type, name) \
+name = (type*) (((intptr_t) name##_buf + 0xf) & ~0xf)
+
+#define QUADWORD_ALIGNED_VAR(type, name) \
+QUADWORD_ALIGNED_VAR_DECLARE(type, name); \
+QUADWORD_ALIGNED_VAR_INIT(type, name)
+
+
+/* "*NOPWD    " in EBCDIC */
+#define NOPWD   "\x5C\xD5\xD6\xD7\xE6\xC4\x40\x40\x40\x40"
+
+/* "*CURRENT  " in EBCDIC */
+#define CURRENT "\x5C\xC3\xE4\xD9\xD9\xC5\xD5\xE3\x40\x40"
+
+
+
+typedef struct {
+	char name[27];
+} job_name_t;
+
+/* '*' followed by 25 blanks in EBCDIC */
+#define JOB_NAME_CURRENT ("\x5C\x40\x40\x40\x40\x40\x40\x40\x40\x40" \
+"\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40" \
+"\x40\x40\x40\x40\x40\x40")
+
+typedef struct {
+	char id[17];
+} internal_jobid_t;
+
+/* 16 blanks in EBCDIC */
+#define JOBID_IGNORE ("\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40" \
+"\x40\x40\x40\x40\x40\x40")
+
+/* "JOBC0200" in EBCDIC */
+#define JOBC0200 "\xD1\xD6\xC2\xC3\xF0\xF2\xF0\xF0"
+
+/* "JOBC0300" in EBCDIC */
+#define JOBC0300 "\xD1\xD6\xC2\xC3\xF0\xF3\xF0\xF0"
+
+
+// this is the 1252 to 37 conversion table.
+static const unsigned char a2e_table[256] =
+{
+	0x00,0x01,0x02,0x03,0x37,0x2d,0x2e,0x2f,0x16,0x05,0x25,0x0b,0x0c,0x0d,0x0e,0x0f,
+	0x10,0x11,0x12,0x13,0x3c,0x3d,0x32,0x26,0x18,0x19,0x3f,0x27,0x1c,0x1d,0x1e,0x1f,
+	0x40,0x4f,0x7f,0x4a,0x67,0x6c,0x50,0x7d,0x4d,0x5d,0x5c,0x4e,0x6b,0x60,0x4b,0x61,
+	0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0x7a,0x5e,0x4c,0x7e,0x6e,0x6f,
+	0x80,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,
+	0xd7,0xd8,0xd9,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0x9e,0xe0,0x9f,0x5f,0x6d,
+	0x79,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x91,0x92,0x93,0x94,0x95,0x96,
+	0x97,0x98,0x99,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0x9c,0xbb,0x47,0xdc,0x07,
+	0x20,0x21,0x22,0x23,0x24,0x15,0x06,0x17,0x28,0x29,0x2a,0x2b,0x2c,0x09,0x0a,0x1b,
+	0x30,0x31,0x1a,0x33,0x34,0x35,0x36,0x08,0x38,0x39,0x3a,0x3b,0x04,0x14,0x3e,0xff,
+	0x41,0xaa,0xb0,0xb1,0x5a,0xb2,0x70,0xb5,0xbd,0xb4,0x9a,0x8a,0xba,0xca,0xaf,0xbc,
+	0x90,0x8f,0xea,0xfa,0xbe,0xa0,0xb6,0xb3,0x9d,0xda,0x9b,0x8b,0xb7,0xb8,0xb9,0xab,
+	0x64,0x65,0x62,0x66,0x63,0x5b,0x7b,0x68,0x74,0x71,0x72,0x73,0x78,0x75,0x76,0x77,
+	0xac,0x69,0xed,0xee,0xeb,0xef,0xec,0xbf,0x7c,0xfd,0xfe,0xfb,0xfc,0xad,0xae,0x59,
+	0x44,0x45,0x42,0x46,0x43,0xd0,0xc0,0x48,0x54,0x51,0x52,0x53,0x58,0x55,0x56,0x57,
+	0x8c,0x49,0xcd,0xce,0xcb,0xcf,0xcc,0xe1,0x6a,0xdd,0xde,0xdb,0xa1,0x8d,0x8e,0xdf,
+};
+
+// this is the 37 to 1252 conversion table.
+static const unsigned char e2a_table[256] =
+{
+	0x00,0x01,0x02,0x03,0x9c,0x09,0x86,0x7f,0x97,0x8d,0x8e,0x0b,0x0c,0x0d,0x0e,0x0f,
+	0x10,0x11,0x12,0x13,0x9d,0x85,0x08,0x87,0x18,0x19,0x92,0x8f,0x1c,0x1d,0x1e,0x1f,
+	0x80,0x81,0x82,0x83,0x84,0x0a,0x17,0x1b,0x88,0x89,0x8a,0x8b,0x8c,0x05,0x06,0x07,
+	0x90,0x91,0x16,0x93,0x94,0x95,0x96,0x04,0x98,0x99,0x9a,0x9b,0x14,0x15,0x9e,0x1a,
+	0x20,0xa0,0xe2,0xe4,0xe0,0xe1,0xe3,0x7d,0xe7,0xf1,0x23,0x2e,0x3c,0x28,0x2b,0x21,
+	0x26,0xe9,0xea,0xeb,0xe8,0xed,0xee,0xef,0xec,0xdf,0xa4,0xc5,0x2a,0x29,0x3b,0x5e,
+	0x2d,0x2f,0xc2,0xc4,0xc0,0xc1,0xc3,0x24,0xc7,0xd1,0xf8,0x2c,0x25,0x5f,0x3e,0x3f,
+	0xa6,0xc9,0xca,0xcb,0xc8,0xcd,0xce,0xcf,0xcc,0x60,0x3a,0xc6,0xd8,0x27,0x3d,0x22,
+	0x40,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0xab,0xbb,0xf0,0xfd,0xfe,0xb1,
+	0xb0,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0xaa,0xba,0x7b,0xb8,0x5b,0x5d,
+	0xb5,0xfc,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0xa1,0xbf,0xd0,0xdd,0xde,0xae,
+	0xa2,0xa3,0xa5,0xb7,0xa9,0xa7,0xb6,0xbc,0xbd,0xbe,0xac,0x7c,0xaf,0xa8,0xb4,0xd7,
+	0xe6,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0xad,0xf4,0xf6,0xf2,0xf3,0xf5,
+	0xe5,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0xb9,0xfb,0x7e,0xf9,0xfa,0xff,
+	0x5c,0xf7,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0xb2,0xd4,0xd6,0xd2,0xd3,0xd5,
+	0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0xb3,0xdb,0xdc,0xd9,0xda,0x9f,
+};
+
+
+// ------------------------------------------------------------------
+// Function:
+//   fast_e2a
+// Purpose:
+//   Convert EBCDIC to ASCII/ANSI
+//   when the only characters in the source are invariant characters.
+// ------------------------------------------------------------------
+
+/* In place conversion for EBCDIC -> ASCII when data is in the
+ * invariant range. Useful for message ids and such
+ */
+void fast_e2a(char* src, size_t src_len) {
+	for(size_t i = 0; i < src_len; ++i) {
+		src[i] = e2a_table[*(unsigned char*) src[i]];
+	}
+}
+
+
+/* In place conversion for ASCII -> EBCDIC when data is in the
+ * invariant range. Useful for message ids and such
+ */
+void fast_a2e(char* src, size_t src_len) {
+	for(size_t i = 0; i < src_len; ++i) {
+		src[i] = a2e_table[*(unsigned char*) src[i]];
+	}
+}
+
+
+
+
+
+#define INPUT_CONVERT_FAILED -20003
+
+static int init_done = 0;
+
+#define INIT() \
+	if(!init_done) { \
+		pase_init(); \
+		init_done = 1; \
+	}
+
+static iconv_t ascii_to_ebcdic;
+static iconv_t ebcdic_to_ascii;
+
+/* PASE (ASCII) and job CCSIDs as well as the character set
+   representation of the CCSIDs. */
+static int paseCCSID, jobCCSID;
+
+QUADWORD_ALIGNED_VAR_DECLARE(ILEpointer, QsyGetProfileHandle_ptr);
+QUADWORD_ALIGNED_VAR_DECLARE(ILEpointer, QsyGetProfileHandleNoPwd_ptr);
+QUADWORD_ALIGNED_VAR_DECLARE(ILEpointer, QsySetToProfileHandle_ptr);
+QUADWORD_ALIGNED_VAR_DECLARE(ILEpointer, QsyReleaseProfileHandle_ptr);
+QUADWORD_ALIGNED_VAR_DECLARE(ILEpointer, QWTCHGJB_ptr);
+QUADWORD_ALIGNED_VAR_DECLARE(ILEpointer, Qp0zSetTerminalMode_ptr);
+QUADWORD_ALIGNED_VAR_DECLARE(ILEpointer, Qp0zIsATerminal_ptr);
+
+static void open_converters()
+{
+	paseCCSID = Qp2paseCCSID();
+	jobCCSID = Qp2jobCCSID();
+	
+	debug("pase ccsid is %d, job ccsid is %d", paseCCSID, jobCCSID);
+	
+	const char* charset_ascii = ccsidtocs(paseCCSID);
+	const char* charset_ebcdic = ccsidtocs(jobCCSID);
+
+	ascii_to_ebcdic = iconv_open(charset_ebcdic, charset_ascii);
+	if (ascii_to_ebcdic == (iconv_t)-1) {
+		fatal("Cannot convert from %s (CCSID %d) to %s (CCSID %d)\n",
+			charset_ascii,
+			paseCCSID,
+			charset_ebcdic,
+			jobCCSID
+			);
+	}
+
+	ebcdic_to_ascii = iconv_open(charset_ascii, charset_ebcdic);
+	if (ebcdic_to_ascii == (iconv_t)-1) {
+		fatal("Cannot convert from %s (CCSID %d) to %s (CCSID %d)\n",
+			charset_ebcdic,
+			jobCCSID,
+			charset_ascii,
+			paseCCSID
+			);
+	}
+}
+
+static void pase_init(void)
+{
+	unsigned long long mark;
+	int rc;
+
+	debug("pase_init");
+	mark = _ILELOADX("QSYS/QSYPHANDLE", ILELOAD_LIBOBJ);
+	if (mark == -1) {
+		fatal("Error loading service program QSYS/QSYPHANDLE, errno = %d\n", errno);
+	}
+
+	QUADWORD_ALIGNED_VAR_INIT(ILEpointer, QsyGetProfileHandle_ptr);
+	rc = _ILESYMX(QsyGetProfileHandle_ptr, mark, "QsyGetProfileHandle");
+	if (rc == -1) {
+		fatal("Error resolving to procedure QsyGetProfileHandle in QSYS/QSYPHANDLE, errno = %d\n", errno);
+	}
+	
+	QUADWORD_ALIGNED_VAR_INIT(ILEpointer, QsyGetProfileHandleNoPwd_ptr);
+	rc = _ILESYMX(QsyGetProfileHandleNoPwd_ptr, mark, "QsyGetProfileHandleNoPwd");
+	if (rc == -1) {
+		fatal("Error resolving to procedure QsyGetProfileHandleNoPwd in QSYS/QSYPHANDLE, errno = %d\n", errno);
+	}
+	
+	QUADWORD_ALIGNED_VAR_INIT(ILEpointer, QsySetToProfileHandle_ptr);
+	rc = _ILESYMX(QsySetToProfileHandle_ptr, mark, "QsySetToProfileHandle");
+	if (rc == -1) {
+		fatal("Error resolving to procedure QsySetToProfileHandle in QSYS/QSYPHANDLE, errno = %d\n", errno);
+	}
+	
+	QUADWORD_ALIGNED_VAR_INIT(ILEpointer, QsyReleaseProfileHandle_ptr);
+	rc = _ILESYMX(QsyReleaseProfileHandle_ptr, mark, "QsyReleaseProfileHandle");
+	if (rc == -1) {
+		fatal("Error resolving to procedure QsyReleaseProfileHandle in QSYS/QSYPHANDLE, errno = %d\n", errno);
+	}
+	
+	QUADWORD_ALIGNED_VAR_INIT(ILEpointer, QWTCHGJB_ptr);
+	rc = _RSLOBJ2(QWTCHGJB_ptr, RSLOBJ_TS_PGM, "QWTCHGJB", "QSYS");
+	if (rc == -1) {
+		fatal("Error resolving QWTCHGJB program\n");
+	}
+	
+	
+	mark = _ILELOADX("QSYS/QP0ZTRMLC", ILELOAD_LIBOBJ);
+	if (mark == -1) {
+		fatal("Error loading service program QSYS/QP0ZTRMLC, errno = %d\n", errno);
+	}
+	
+	QUADWORD_ALIGNED_VAR_INIT(ILEpointer, Qp0zSetTerminalMode_ptr);
+	rc = _ILESYMX(Qp0zSetTerminalMode_ptr, mark, "Qp0zSetTerminalMode");
+	if (rc == -1) {
+		fatal("Error resolving to procedure QsyReleaseProfileHandle in QSYS/QP0ZTRMLC, errno = %d\n", errno);
+	}
+	
+	QUADWORD_ALIGNED_VAR_INIT(ILEpointer, Qp0zIsATerminal_ptr);
+	rc = _ILESYMX(Qp0zIsATerminal_ptr, mark, "Qp0zIsATerminal");
+	if (rc == -1) {
+		fatal("Error resolving to procedure QsyReleaseProfileHandle in QSYS/QP0ZTRMLC, errno = %d\n", errno);
+	}
+	
+	open_converters();
+}
+
+void pase_post_fork_child() {
+	debug("pase_post_fork_child");
+	pase_init();
+}
+
+static inline int iconv_wrapper(iconv_t cd, const char* src, size_t srclen, char* dst, size_t dstlen) {
+	char* src_adj = (char*) src;
+	char* dst_adj = dst;
+	
+	iconv(cd, &src_adj, &srclen, &dst_adj, &dstlen);
+	
+	return src_adj == 0;
+}
+
+#define a2e(s, sl, d, dl) iconv_wrapper(ascii_to_ebcdic, s, sl, d, dl)
+#define e2a(s, sl, d, dl) iconv_wrapper(ebcdic_to_ascii, s, sl, d, dl)
+
+
+
+/*********************************************************************/
+/* Each of these routines follows a flow generally like so:          */
+/*                                                                   */
+/* 1) Call the SETUP macro to verify the environment is setup        */
+/* 2) (if input or output parms are variable length and contain      */
+/*    character data) allocate temporary buffers of equal size       */
+/*    as the parms provided                                          */
+/* 3) Convert ASCII input parms/fields into EBCDIC placing the       */
+/*    EBCDIC output into temporary parm buffers                      */
+/* 4) (if there are binary fields in a parm structure containing     */
+/*    character data) copy the binary fields from the input parm     */
+/*    to the temporary parm structure                                */
+/* 5) Setup the argument list to call the ILE routine.  Pure binary  */
+/*    arguments point to the parms provided, arguments with          */
+/*    character data point to temporary parms with the EBCDIC        */
+/*    values                                                         */
+/* 6) Call the ILE routine                                           */
+/* 7) (if there is character data in the output) convert the         */
+/*    character data from EBCDIC to ASCII                            */
+/*********************************************************************/
+
+
+
+int Qp0zSetTerminalMode(unsigned char mode, unsigned char type)
+{
+	static const return_type = RESULT_INT32;
+	static const arg_type_t signature[] =
+	{
+		ARG_UINT8,      /* requires #pragma nowiden in ILE code */
+		ARG_UINT8,      /* requires #pragma nowiden in ILE code */
+		ARG_MEMPTR,
+		ARG_END
+	};
+	
+	typedef struct {
+		ILEarglist_base base;
+		unsigned char mode;
+		unsigned char type;
+		ILEpointer reserved;
+	} arglist_t;
+	
+	INIT();
+	
+	QUADWORD_ALIGNED_VAR(arglist_t, arglist);
+	
+	arglist->mode = mode;
+	arglist->type = type;
+	arglist->reserved.s.addr = (address64_t) NULL;
+	
+	int rc = _ILECALL(Qp0zSetTerminalMode_ptr,
+			  &arglist->base,
+			  signature,
+			  return_type);
+	rc = rc ? -1 : arglist->base.result.s_int32.r_int32;
+	
+	return rc;
+}
+
+int Qp0zIsATerminal(int fd)
+{
+	static return_type = RESULT_INT32;
+	static arg_type_t signature[] =
+	{
+		ARG_INT32,
+		ARG_END
+	};
+	
+	typedef struct {
+		ILEarglist_base base;
+		int fd;
+	} arglist_t;
+	
+	INIT();
+	
+	QUADWORD_ALIGNED_VAR(arglist_t, arglist);
+	
+	arglist->fd = fd;
+	
+	int rc = _ILECALL(Qp0zIsATerminal_ptr,
+			  &arglist->base,
+			  signature,
+			  return_type);
+	
+	rc = rc ? -1 : arglist->base.result.s_int32.r_int32;
+	
+	return rc;
+}
+
+/* IBM i user profile naming rules:
+ * 
+ * IBM i user names must follow *SNAME object naming rules
+ * Simple names (*SNAME)
+ *   Simple names are used for control language (CL) variables, labels,
+ *   and keywords to simplify the syntax of CL. Simple names are the
+ *   same as unquoted basic names but with one exception: periods (.)
+ *   cannot be used.
+ *
+ * *NAME (basic name in unquoted form)
+ *   Every basic name can begin with the characters A-Z, $, #, or @
+ *   and can be followed by up to nine characters. The remaining
+ *   characters can include the same characters as the first but can
+ *   also include numbers 0-9, underscores (_), and periods (.).
+ *   Lowercase letters are changed to uppercase letters by the system.
+ *   Basic names used in IBM-supplied commands can be no longer than
+ *   10 characters. However, in your own commands, you can define
+ *   parameters of type *NAME (specified on the TYPE parameter of the
+ *   PARM or ELEM statements) with up to 256 characters.
+ * 
+ * So, first letter must be A-Z, $, #, or @. Can be followed by 9 more
+ * characters, A-Z, 0-9, $, #, @, or _.
+ */
+
+
+
+int error_code_post_call(Qus_EC_t* error_code) {
+	fast_e2a(error_code->Msg_Id, sizeof(error_code->Msg_Id));
+	error_code->Reserved = '\0'; /* trick for null-terminating Msg_Id */
+	
+	return error_code->Bytes_Available;
+}
+
+/*********************************************************************/
+/* Function name: QsyGetProfileHandle                                */
+/*********************************************************************/
+int QsyGetProfileHandle(profile_handle_t* handle, const char * name,
+                         const char * password, int password_len,
+                         unsigned int password_ccsid,
+                         Qus_EC_t* error_code) {
+	int rc;
+	
+	char name_upper[11];
+	char name_ebcdic[11];
+	
+	static const return_type = RESULT_VOID;
+	static const arg_type_t signature[] = {
+		ARG_MEMPTR, /* unsigned char * profile handle */
+		ARG_MEMPTR, /* char * user profile name */
+		ARG_MEMPTR, /* char * user profile password */
+		ARG_INT32,  /* int length of password */
+		ARG_UINT32, /* CCSID of password */
+		ARG_MEMPTR, /* Qus_EC_t* error code */
+		ARG_END
+	};
+	
+	typedef struct {
+		ILEarglist_base base;
+		ILEpointer handle;
+		ILEpointer name;
+		ILEpointer password;
+		int password_len;
+		unsigned int password_ccsid;
+		ILEpointer error_code;
+	} arglist_t;
+	
+	if(error_code == NULL || error_code->Bytes_Provided < sizeof(Qus_EC_t)) {
+		errno = EINVAL;
+		return -1;
+	}
+	
+	// Space pad out name to 10 characters
+	rc = snprintf(name_upper, sizeof(name_upper), "%-10s", name);
+	if(rc < 0 || rc > sizeof(name_upper)) {
+		errno = EINVAL;
+		return -1;
+	}
+	
+	// Convert user name to uppercase
+	for(size_t i = 0; i < sizeof(name_upper)-1; ++i) {
+		name_upper[i] = toupper(name_upper[i]);
+	}
+	
+	INIT();
+	
+	rc = a2e(name_upper, sizeof(name_upper), name_ebcdic, sizeof(name_ebcdic));
+	if(rc < 0) {
+		return rc;
+	}
+	
+	QUADWORD_ALIGNED_VAR(arglist_t, arglist);
+	
+	arglist->handle.s.addr = (address64_t) handle;
+	arglist->name.s.addr = (address64_t) name_ebcdic;
+	arglist->password.s.addr = (address64_t) password;
+	arglist->password_len = password_len;
+	arglist->password_ccsid = password_ccsid == 0 ? paseCCSID : password_ccsid;
+	arglist->error_code.s.addr = (address64_t) error_code;
+	debug("QsyGetProfileHandle('%s', %s, %d, %d)", name_upper, password, password_len, password_ccsid);
+
+	
+	rc = _ILECALL(QsyGetProfileHandle_ptr, &arglist->base, signature, return_type);
+	if(rc == ILECALL_NOERROR) {
+		rc = error_code_post_call(error_code);
+	}
+	
+	return rc;
+}
+
+/*********************************************************************/
+/* Function name: QsyGetProfileHandleNoPwd                           */
+/*********************************************************************/
+int QsyGetProfileHandleNoPwd(profile_handle_t* handle,
+                         const char * name,
+                         const char * option,
+                         Qus_EC_t* error_code) {
+	int rc;
+	
+	char name_upper[11];
+	char name_ebcdic[11];
+	
+	static const return_type = RESULT_VOID;
+	
+	static const arg_type_t signature[] = {
+		ARG_MEMPTR, /* unsigned char * profile handle */
+		ARG_MEMPTR, /* char * user profile name */
+		ARG_MEMPTR, /* char * user profile option */
+		ARG_MEMPTR, /* Qus_EC_t* error code */
+		ARG_END
+	};
+	
+	typedef struct {
+		ILEarglist_base base;
+		ILEpointer handle;
+		ILEpointer name;
+		ILEpointer option;
+		ILEpointer error_code;
+	} arglist_t;
+	
+	if(error_code == NULL || error_code->Bytes_Provided < sizeof(Qus_EC_t)) {
+		errno = EINVAL;
+		return -1;
+	}
+	
+	// Space pad out name to 10 characters
+	rc = snprintf(name_upper, sizeof(name_upper), "%-10s", name);
+	if(rc < 0 || rc > sizeof(name_upper)) {
+		errno = EINVAL;
+		return -1;
+	}
+	
+	// Convert user name to uppercase
+	for(size_t i = 0; i < sizeof(name_upper)-1; ++i) {
+		name_upper[i] = toupper(name_upper[i]);
+	}
+	
+	INIT();
+	
+	rc = a2e(name_upper, sizeof(name_upper), name_ebcdic, sizeof(name_ebcdic));
+	if(rc < 0) {
+		return rc;
+	}
+	
+	QUADWORD_ALIGNED_VAR(arglist_t, arglist);
+	
+	arglist->handle.s.addr = (address64_t) handle;
+	arglist->name.s.addr = (address64_t) name_ebcdic;
+	arglist->option.s.addr = (address64_t) option;
+	arglist->error_code.s.addr = (address64_t) error_code;
+	
+	rc = _ILECALL(QsyGetProfileHandleNoPwd_ptr, &arglist->base, signature, return_type);
+	if(rc == ILECALL_NOERROR) {
+		rc = error_code_post_call(error_code);
+	}
+	
+	return rc;
+}
+
+/*********************************************************************/
+/* Function name: QsySetToProfileHandle                           */
+/*********************************************************************/
+int QsySetToProfileHandle(profile_handle_t* handle, Qus_EC_t* error_code) {
+	int rc;
+	
+	static const return_type = RESULT_VOID;
+	static const arg_type_t signature[] = {
+		ARG_MEMPTR, /* unsigned char * profile handle */
+		ARG_MEMPTR, /* Qus_EC_t* error code */
+		ARG_END
+	};
+	
+	typedef struct {
+		ILEarglist_base base;
+		ILEpointer handle;
+		ILEpointer error_code;
+	} arglist_t;
+	
+	
+	if(error_code == NULL || error_code->Bytes_Provided < sizeof(Qus_EC_t)) {
+		errno = EINVAL;
+		return -1;
+	}
+	
+	INIT();
+	
+	QUADWORD_ALIGNED_VAR(arglist_t, arglist);
+	
+	arglist->handle.s.addr = (address64_t)handle;
+	arglist->error_code.s.addr = (address64_t)error_code;
+	
+	rc = _ILECALL(QsySetToProfileHandle_ptr, &arglist->base, signature, return_type);
+	if(rc == ILECALL_NOERROR) {
+		rc = error_code_post_call(error_code);
+	}
+
+	return rc;
+}
+
+/*********************************************************************/
+/* Function name: QsyReleaseProfileHandle                           */
+/*********************************************************************/
+int QsyReleaseProfileHandle(profile_handle_t* handle, Qus_EC_t* error_code) {
+	int rc;
+	
+	static const return_type = RESULT_VOID;
+	static const arg_type_t signature[] = {
+		ARG_MEMPTR, /* unsigned char* profile handle */
+		ARG_MEMPTR, /* Qus_EC_t* error code */
+		ARG_END
+	};
+	
+	typedef struct {
+		ILEarglist_base base;
+		ILEpointer handle;
+		ILEpointer error_code;
+	} arglist_t;
+	
+	
+	if(error_code == NULL || error_code->Bytes_Provided < sizeof(Qus_EC_t)) {
+		errno = EINVAL;
+		return -1;
+	}
+	
+	INIT();
+	
+	QUADWORD_ALIGNED_VAR(arglist_t, arglist);
+	
+	arglist->handle.s.addr = (address64_t)handle;
+	arglist->error_code.s.addr = (address64_t)error_code;
+	
+	rc = _ILECALL(QsyReleaseProfileHandle_ptr, &arglist->base, signature, return_type);
+	if(rc == ILECALL_NOERROR) {
+		rc = error_code_post_call(error_code);
+	}
+	
+	return rc;
+}
+
+/* QWTCHGJB PASE wrapper
+ * If there's an error calling the ILE program, returns -1 and errno set
+ * If ILE program was called, returns bytes available returned in error_code
+ * parameter, which will be 0 if no error occured from QWTCHGJB.
+ * 
+ * NOTE: all parameters must be in EBCDIC job encoding
+ */
+int QWTCHGJB(job_name_t* job_name, internal_jobid_t* job_id, const char* format,
+			 void* info, Qus_EC_t* error_code) {
+	int rc;
+	
+	if(error_code == NULL || error_code->Bytes_Provided < sizeof(Qus_EC_t)) {
+		errno = EINVAL;
+		return -1;
+	}
+		
+	void* args[] = {
+		job_name,
+		job_id,
+		(void*) format,
+		info,
+		error_code,
+		NULL
+	};
+	
+	INIT();
+	
+	debug("QWTCHGJB");
+	rc = _PGMCALL(QWTCHGJB_ptr, args, 0);
+	if(rc == 0) {
+		rc = error_code_post_call(error_code);
+	}
+	
+	return rc;
+}
+
+/*
+ * record_failed_login: record audit entry for failed login
+ */
+void
+record_failed_login(const char *user, const char *hostname, const char *ttyname)
+{
+	int rc;
+	Qus_EC_t error_code = DEFAULT_ERROR_CODE;
+	profile_handle_t handle;
+	const char * password = "\0";
+	
+	rc = QsyGetProfileHandle(&handle, user, password, 1, 0, &error_code);
+	
+	debug("record_failed_login:  GetPH user=%s rc=%d avail=%d msgid=%.7s",
+		user, rc, error_code.Bytes_Available, error_code.Msg_Id);
+	if(rc==0) { /* should never happen */
+		rc = QsyReleaseProfileHandle(&handle, &error_code);
+			debug("record_failed_login:  QsyReleaseProfileHandle rc=%d avail=%d msgid=%.7s",
+		rc, error_code.Bytes_Available, error_code.Msg_Id);
+	}
+	return;
+}
+
+int pase_temporarily_use_uid(const struct passwd *pw, profile_handle_t* prev, profile_handle_t* cur) {
+	int rc;
+	Qus_EC_t error_code = DEFAULT_ERROR_CODE;
+	
+	debug("pase_temporarily_use_uid");
+	rc = QsyGetProfileHandleNoPwd(prev, "*CURRENT", NOPWD, &error_code);
+	if (rc != 0) {
+		debug("QsyGetProfileHandleNoPwd *CURRENT %s", rc < 0 ? "" : error_code.Msg_Id);
+		return rc;
+	}
+	
+	rc = QsyGetProfileHandleNoPwd(cur, pw->pw_name, NOPWD, &error_code);
+	if (rc != 0) {
+		debug("QsyGetProfileHandleNoPwd %s %s", pw->pw_name, rc < 0 ? "" : error_code.Msg_Id);
+		return rc;
+	}
+	
+	rc = QsySetToProfileHandle(cur, &error_code);
+	if (rc != 0) {
+		debug("QsySetToProfileHandle %s", rc < 0 ? "" : error_code.Msg_Id);
+		return rc;
+	}
+	
+	return 0;
+}
+
+int pase_restore_uid(profile_handle_t* prev, profile_handle_t* cur) {
+	int rc;
+	Qus_EC_t error_code = DEFAULT_ERROR_CODE;
+	
+	debug("pase_restore_uid");
+	
+	rc = QsySetToProfileHandle(prev, &error_code);
+	if (rc != 0) {
+		debug("QsySetToProfileHandle %s", rc < 0 ? "" : error_code.Msg_Id);
+		return rc;
+	}
+	
+	rc = QsyReleaseProfileHandle(prev, &error_code);
+	if (rc != 0) {
+		debug("QsyReleaseProfileHandle prev %s", rc < 0 ? "" : error_code.Msg_Id);
+	}
+	
+	rc = QsyReleaseProfileHandle(cur, &error_code);
+	if (rc != 0) {
+		debug("QsyReleaseProfileHandle cur %s", rc < 0 ? "" : error_code.Msg_Id);
+	}
+	
+	return 0;
+}
+
+int setresuid(uid_t ruid, uid_t euid, uid_t suid) {
+	int rc;
+	
+	Qus_EC_t error_code = DEFAULT_ERROR_CODE;
+	profile_handle_t handle;
+	
+	if(ruid != euid && ruid != suid) {
+		errno = EINVAL;
+		return -1;
+	}
+	
+	struct passwd* pw = getpwuid(ruid);
+	if(pw == NULL) {
+		return -1;
+	}
+
+	rc = QsyGetProfileHandleNoPwd(&handle, pw->pw_name, NOPWD, &error_code);
+	
+	debug3("setresuid GetPH pw_name %s rc=%d avail=%d msgid=%.7s",
+		  pw->pw_name, rc, error_code.Bytes_Available, error_code.Msg_Id);
+	if (rc != 0)
+		fatal("QsyGetProfileHandleNoPwd %s %.7s", pw->pw_name, error_code.Msg_Id);
+	
+	rc = QsySetToProfileHandle(&handle, &error_code);
+	debug("permanently_set_uid SetPH rc=%d avail=%d msgid=%.7s",
+		  rc, error_code.Bytes_Available, error_code.Msg_Id);
+	if (rc != 0)
+		fatal("QsySetToProfileHandle %.7s", error_code.Msg_Id);
+	
+	rc = QsyReleaseProfileHandle(&handle, &error_code);
+	debug("permanently_set_uid ReleasePH handle rc=%d avail=%d msgid=%.7s",
+		  rc, error_code.Bytes_Available, error_code.Msg_Id);
+	
+	if(pase_reset_curent_job_attributes() >= 0) {
+		/* We've reset the job attributes, potentially changing the job
+		 * CCSID, reopen the converters
+		 */
+		open_converters();
+	}
+	debug("permanently_set_uid QWTCHGJB rc=%d avail=%d msgid=%.7s",
+		  rc, error_code.Bytes_Available, error_code.Msg_Id);
+	/* ignore errors on this -- compatibility w/ prior releases when we did not do at all */
+	/* and in chroot case, this will fail with missing QSYS stuff /qsys.lib/en_us.locale  */
+	/* if (rc != 0)                                                                       */
+	/*   fatal("permanently_set_uid QWTCHGJB rc %.7s", error_code.Msg_Id)                   */
+	
+	return rc;
+}
+
+int setresgid(gid_t rgid, gid_t egid, gid_t sgid) {
+	return 0;
+}
+
+int pase_setgroups(int size, gid_t* list) {
+	if(size == 0) {
+		return 0;
+	}
+	
+	return setgroups(size, list);
+}
+
+// /* Dummy function that AIX code uses to set AIX usrinfo
+//  * area. I don't think we have this in PASE
+//  */
+// // TODO: Shouldn't need this, actually
+// void aix_usrinfo(struct passwd *pw) {
+// }
+
+
+
+
+int pase_reset_curent_job_attributes() {
+	int rc;
+	Qus_EC_t error_code = DEFAULT_ERROR_CODE;
+	
+	job_name_t job_name = { JOB_NAME_CURRENT };
+	internal_jobid_t job_id = { JOBID_IGNORE };
+	
+	typedef struct {
+		int number_of_records;
+		int key;
+		char data[10];
+		char reserved[2];
+	} info_t;
+	
+	info_t info = {
+		1,
+		2701, /* ALL JOBC0300 attributes */
+		"\x5C\xC3\xE4\xD9\xE4\xE2\xD9\x40\x40\x40", /* '*CURUSR' in EBCDIC, padded with blanks */
+		"\x40\x40" /* EBCDIC blanks */
+	};
+	
+	debug("pase_reset_curent_job_attributes");
+	debug("pase ccsid is %d, job ccsid is %d", paseCCSID, jobCCSID);
+	rc = QWTCHGJB(&job_name, &job_id, JOBC0300, &info, &error_code); /* 1 == change job server type to sshd */
+	if(rc) {
+		debug2("pase_reset_curent_job_attributes: errno=%d", errno);
+	} else if(rc > 0) {
+		debug2("pase_reset_curent_job_attributes: msgid=%s", error_code.Msg_Id);
+	}
+	
+	return rc;
+}
+
+int pase_set_server_type() {
+	int rc;
+	Qus_EC_t error_code = DEFAULT_ERROR_CODE;
+	
+	job_name_t job_name = { JOB_NAME_CURRENT };
+	internal_jobid_t job_id = { JOBID_IGNORE };
+	
+	typedef struct {
+		int number_of_records;
+		int record_length;
+		int key;
+		char type;
+		char reserved[3];
+		int data_length;
+		char data[30];
+	} info_t;
+	
+#define sizeof_member(type, member) sizeof(((type *)0)->member)
+	
+	info_t info = {
+		1,
+		sizeof_member(info_t, data) + offsetof(info_t, data) - offsetof(info_t, record_length),
+		1911, /* Key for specifying Server type */
+		'\xC3', /* 'C' in EBCDIC */
+		"\x40\x40\x40", /* EBCDIC blanks */
+		sizeof_member(info_t, data),
+		/* 'QIBM_SSHD' in EBCDIC, padded with blanks */
+		"\xD8\xC9\xC2\xD4\x6D\xE2\xC8\xC4\x40\x40\x40\x40\x40\x40\x40" \
+		"\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40"
+	};
+	
+	debug("pase_set_server_type");
+	rc = QWTCHGJB(&job_name, &job_id, JOBC0200, &info, &error_code); /* 1 == change job server type to sshd */
+	if(rc < 0) {
+		debug2("pase_set_job_type: errno=%d", errno);
+	} else if(rc > 0) {
+		debug2("pase_set_job_type: msgid=%s", error_code.Msg_Id);
+	}
+	
+	return rc;
+}
+
+
+void pase_set_legacy_chroot_dir(ServerOptions* options, struct passwd* pw) {
+	/* If the user is using the ChrootDirectory option
+	 * don't mess with it.
+	 */
+	if(options->chroot_directory != NULL &&
+	   strcasecmp(options->chroot_directory, "none") != 0) {
+		return;
+	}
+	
+	/* If the user's home directory doesn't have /./
+	 * somewhere in the path, we don't chroot
+	 */
+	char* dot_dir = strstr(pw->pw_dir, "/./");
+	if(!dot_dir) {
+		return;
+	}
+	
+	size_t chroot_len = (size_t) (dot_dir - pw->pw_dir);
+	options->chroot_directory = xstrdup(pw->pw_dir);
+	options->chroot_directory[chroot_len] = '\0';
+	
+	/* Skip past the /./ in the path to the actual
+	 * user's home directory in the chroot
+	 */
+	pw->pw_dir = &dot_dir[3];
+}
+
+
+/*
+ * Do authentication via ILE QsyGetProfileHandle function.
+ */
+int sys_auth_passwd(Authctxt *ctxt, const char *password)
+{
+	int rc;
+	Qus_EC_t error_code = DEFAULT_ERROR_CODE;
+	profile_handle_t handle;
+	
+	struct passwd* pw = ctxt->pw;
+	
+	/* no point in checking invalid users */
+	if(!ctxt->valid) {
+		return 0;
+	}
+	
+	rc = QsyGetProfileHandle(&handle, pw->pw_name, password, strlen(password), 0, &error_code);
+	
+	if(rc) {
+		debug("QsyGetProfileHandle pw->pw_name=%s rc=%d avail=%d msgid=%.7s\n",
+		      pw->pw_name, rc, error_code.Bytes_Available, error_code.Msg_Id);
+		return 0;
+	}
+	
+	rc = QsyReleaseProfileHandle(&handle, &error_code);
+	if(rc) {
+		debug("auth_password:  ReleasePH rc=%d avail=%d msgid=%.7s",
+				rc, error_code.Bytes_Available, error_code.Msg_Id);
+	}
+	
+	return 1;
+}
+
+
+int sys_auth_record_login(const char *user, const char *host, const char *ttynm,
+		      Buffer *loginmsg)
+{
+	// TODO: Figure out what needs to be done here if anything
+	// If nothing, remove this function and remove definition in port-pase.h
+	return 1;
+}
+
+#endif /* __PASE__ */
