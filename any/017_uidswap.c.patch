diff --git a/uidswap.c b/uidswap.c
index 49f76d8..2c7c31d 100644
--- a/uidswap.c
+++ b/uidswap.c
@@ -52,7 +52,10 @@ static int	temporarily_use_uid_effective = 0;
 static uid_t	user_groups_uid;
 static gid_t	*saved_egroups = NULL, *user_groups = NULL;
 static int	saved_egroupslen = -1, user_groupslen = -1;
-
+#ifdef __PASE__
+static char     prevHandle[12];
+static char     profileHandle[12];
+#endif
 /*
  * Temporarily changes to the given uid.  If the effective user
  * id is not root, this does nothing.  This call cannot be nested.
@@ -60,6 +63,7 @@ static int	saved_egroupslen = -1, user_groupslen = -1;
 void
 temporarily_use_uid(struct passwd *pw)
 {
+#ifndef __PASE__
 	/* Save the current euid, and egroups. */
 #ifdef SAVED_IDS_WORK_WITH_SETEUID
 	saved_euid = geteuid();
@@ -133,6 +137,42 @@ temporarily_use_uid(struct passwd *pw)
 	if (seteuid(pw->pw_uid) == -1)
 		fatal("seteuid %u: %.100s", (u_int)pw->pw_uid,
 		    strerror(errno));
+#else
+        int rc;
+        struct {
+            int bytesProvided;
+            int bytesAvailable;
+            char msgID[7];
+            char reserved;
+        } errorCode;
+
+        errorCode.bytesProvided=sizeof(errorCode);
+        errorCode.bytesAvailable = 0;
+        rc = QsyGetProfileHandleNoPwd(prevHandle, "*CURRENT  ", "*NOPWD    ", &errorCode);
+        debug("temporarily_use_uid:  GetPH *current rc=%d avail=%d msgid=%.7s",
+               rc, errorCode.bytesAvailable, errorCode.msgID);
+        if (rc != 0)
+           fatal("QsyGetProfileHandleNoPwd *CURRENT %.7s", errorCode.msgID);
+
+        errorCode.bytesProvided=sizeof(errorCode);
+        errorCode.bytesAvailable = 0;
+        rc = QsyGetProfileHandleNoPwd(profileHandle, pw->pw_name, "*NOPWD    ", &errorCode);
+        debug("temporarily_use_uid:  GetPH pw_name %s rc=%d avail=%d msgid=%.7s",
+               pw->pw_name, rc, errorCode.bytesAvailable, errorCode.msgID);
+        if (rc != 0)
+           fatal("QsyGetProfileHandleNoPwd %s %.7s", pw->pw_name, errorCode.msgID);
+
+        errorCode.bytesProvided=sizeof(errorCode);
+        errorCode.bytesAvailable = 0;
+        rc = QsySetToProfileHandle(profileHandle, &errorCode);
+        debug("temporarily_use_uid:  SetPH rc=%d avail=%d msgid=%.7s",
+               rc, errorCode.bytesAvailable, errorCode.msgID);
+        if (rc != 0)
+           fatal("QsySetToProfileHandle %.7s", errorCode.msgID);
+
+        privileged = 1;
+        temporarily_use_uid_effective = 1;
+#endif /* i5OS_PASE */
 }
 
 /*
@@ -149,6 +189,7 @@ restore_uid(void)
 	if (!temporarily_use_uid_effective)
 		fatal("restore_uid: temporarily_use_uid not effective");
 
+#ifndef __PASE__
 #ifdef SAVED_IDS_WORK_WITH_SETEUID
 	debug("restore_uid: %u/%u", (u_int)saved_euid, (u_int)saved_egid);
 	/* Set the effective uid back to the saved privileged uid. */
@@ -169,6 +210,37 @@ restore_uid(void)
 	if (setgroups(saved_egroupslen, saved_egroups) < 0)
 		fatal("setgroups: %.100s", strerror(errno));
 	temporarily_use_uid_effective = 0;
+#else
+    int rc;
+    struct {
+        int bytesProvided;
+        int bytesAvailable;
+        char msgID[7];
+        char reserved;
+    } errorCode;
+
+    errorCode.bytesProvided=sizeof(errorCode);
+    errorCode.bytesAvailable = 0;
+    rc = QsySetToProfileHandle(prevHandle, &errorCode);
+    debug("restore_uid:  SetPH rc=%d avail=%d msgid=%.7s",
+           rc, errorCode.bytesAvailable, errorCode.msgID);
+    if (rc != 0)
+       fatal("QsySetToProfileHandle %.7s", errorCode.msgID);
+
+    errorCode.bytesProvided=sizeof(errorCode);
+    errorCode.bytesAvailable = 0;
+    rc = QsyReleaseProfileHandle(prevHandle, &errorCode);
+    debug("restore_uid:  ReleasePH prevHandle rc=%d avail=%d msgid=%.7s",
+           rc, errorCode.bytesAvailable, errorCode.msgID);
+
+    errorCode.bytesProvided=sizeof(errorCode);
+    errorCode.bytesAvailable = 0;
+    rc = QsyReleaseProfileHandle(profileHandle, &errorCode);
+    debug("restore_uid:  ReleasePH profileHandle rc=%d avail=%d msgid=%.7s",
+               rc, errorCode.bytesAvailable, errorCode.msgID);
+
+	temporarily_use_uid_effective = 0;
+#endif
 }
 
 /*
@@ -185,6 +257,7 @@ permanently_set_uid(struct passwd *pw)
 
 	if (pw == NULL)
 		fatal("permanently_set_uid: no user given");
+#ifndef __PASE__
 	if (temporarily_use_uid_effective)
 		fatal("permanently_set_uid: temporarily_use_uid effective");
 	debug("permanently_set_uid: %u/%u", (u_int)pw->pw_uid,
@@ -205,6 +278,54 @@ permanently_set_uid(struct passwd *pw)
 
 	if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) < 0)
 		fatal("setresuid %u: %.100s", (u_int)pw->pw_uid, strerror(errno));
+#else
+        int rc;
+        struct {
+            int bytesProvided;
+            int bytesAvailable;
+            char msgID[7];
+            char reserved;
+        } errorCode;
+        char profileHandle[12];
+
+        if (temporarily_use_uid_effective)
+            fatal("permanently_set_uid: temporarily_use_uid effective");
+        debug("permanently_set_uid: %u/%u", (u_int)pw->pw_uid,
+              (u_int)pw->pw_gid);
+
+        errorCode.bytesProvided=sizeof(errorCode);
+        errorCode.bytesAvailable = 0;
+        rc = QsyGetProfileHandleNoPwd(profileHandle, pw->pw_name, "*NOPWD    ", &errorCode);
+        debug("permanently_set_uid GetPH pw_name %s rc=%d avail=%d msgid=%.7s",
+              pw->pw_name, rc, errorCode.bytesAvailable, errorCode.msgID);
+        if (rc != 0)
+            fatal("QsyGetProfileHandleNoPwd %s %.7s", pw->pw_name, errorCode.msgID);
+
+        errorCode.bytesProvided=sizeof(errorCode);
+        errorCode.bytesAvailable = 0;
+        rc = QsySetToProfileHandle(profileHandle, &errorCode);
+        debug("permanently_set_uid SetPH rc=%d avail=%d msgid=%.7s",
+              rc, errorCode.bytesAvailable, errorCode.msgID);
+        if (rc != 0)
+            fatal("QsySetToProfileHandle %.7s", errorCode.msgID);
+
+        errorCode.bytesProvided=sizeof(errorCode);
+        errorCode.bytesAvailable = 0;
+        rc = QsyReleaseProfileHandle(profileHandle, &errorCode);
+        debug("permanently_set_uid ReleasePH profileHandle rc=%d avail=%d msgid=%.7s",
+              rc, errorCode.bytesAvailable, errorCode.msgID);
+
+        errorCode.bytesProvided=sizeof(errorCode);
+        errorCode.bytesAvailable = 0;
+        rc = QWTCHGJB(2, &errorCode); /* 2 == set job attributes to new current user profile */
+        debug("permanently_set_uid QWTCHGJB rc=%d avail=%d msgid=%.7s",
+               rc, errorCode.bytesAvailable, errorCode.msgID);
+        /* ignore errors on this -- compatibility w/ prior releases when we did not do at all */
+        /* and in chroot case, this will fail with missing QSYS stuff /qsys.lib/en_us.locale  */
+        /* if (rc != 0)                                                                       */
+        /*   fatal("permanently_set_uid QWTCHGJB rc %.7s", errorCode.msgID)                   */
+
+#endif
 
 #ifndef NO_UID_RESTORATION_TEST
 	/* Try restoration of GID if changed (test clearing of saved gid) */
