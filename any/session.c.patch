--- a/session.c	2015-06-30 21:35:31.000000000 -0500
+++ b/session.c	2017-01-30 11:20:43.077985911 -0600
@@ -829,7 +829,11 @@
 		char *shell = s->pw->pw_shell;
 
 		if (shell[0] == '\0')	/* empty shell means /bin/sh */
+#ifndef __PASE__
 			shell =_PATH_BSHELL;
+#else
+			shell = options.pase_shell;
+#endif
 		PRIVSEP(audit_run_command(shell));
 	}
 #endif
@@ -1218,6 +1222,13 @@
 	if (getenv("TZ"))
 		child_set_env(&env, &envsize, "TZ", getenv("TZ"));
 
+#ifdef __PASE__
+	/* Needed to support usernames greater than 8 chars in PASE */
+	if (getenv("PASE_USRGRP_LIMITED"))
+		child_set_env(&env, &envsize, "PASE_USRGRP_LIMITED",
+					  getenv("PASE_USRGRP_LIMITED"));
+#endif
+
 	/* Set custom environment options from RSA authentication. */
 	if (!options.use_login) {
 		while (custom_environment) {
@@ -1489,6 +1499,7 @@
 void
 do_setusercontext(struct passwd *pw)
 {
+#ifndef __PASE__
 	char *chroot_path, *tmp;
 #ifdef USE_LIBIAF
 	int doing_chroot = 0;
@@ -1567,6 +1578,44 @@
 	    strcasecmp(options.chroot_directory, "none") != 0) {
 		fatal("server lacks privileges to chroot to ChrootDirectory");
 	}
+#else
+        char *user_dir, *new_dir;
+        
+        /* Chroot feature is enabled */
+        user_dir = xstrdup(pw->pw_dir);
+        new_dir = user_dir + 1;
+        while((new_dir = strstr(new_dir,".")) != NULL)
+        {
+            new_dir--;
+
+            if(strncmp(new_dir,"/./", 3) == 0 )
+            {
+                *new_dir = '\0';
+                new_dir += 2;
+                if(getuid() == 0 )
+                {
+                    debug("do_setusercontext: chroot uid is 0");
+                    if(chroot(user_dir) != 0 )
+                    {
+                        fatal("do_setusercontext: Couldn't chroot to user's directory %s", user_dir);
+                    }
+                    chdir("/");
+                }
+                else
+                {
+                    debug("do_setusercontext: request chroot but sshd uid is not 0 Exiting...");
+                    exit(0);
+                }
+                pw->pw_dir = new_dir;
+                break;
+            }
+            new_dir += 2;
+        }
+        
+		aix_usrinfo(pw);
+		/* Permanently switch to the desired uid. */
+		permanently_set_uid(pw);
+#endif
 
 	if (getuid() != pw->pw_uid || geteuid() != pw->pw_uid)
 		fatal("Failed to set uids to %u.", (u_int) pw->pw_uid);
@@ -1702,7 +1751,9 @@
 			do_motd();
 #else /* HAVE_OSF_SIA */
 		/* When PAM is enabled we rely on it to do the nologin check */
+#ifndef __PASE__
 		if (!options.use_pam)
+#endif
 			do_nologin(pw);
 		do_setusercontext(pw);
 		/*
@@ -1727,7 +1778,11 @@
 	 * Get the shell from the password data.  An empty shell field is
 	 * legal, and means /bin/sh.
 	 */
+#ifndef __PASE__
 	shell = (pw->pw_shell[0] == '\0') ? _PATH_BSHELL : pw->pw_shell;
+#else
+	shell = (pw->pw_shell[0] == '\0') ? options.pase_shell : pw->pw_shell;
+#endif
 
 	/*
 	 * Make sure $SHELL points to the shell from the password file,
